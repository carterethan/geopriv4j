import java.io.File;
import java.io.FileNotFoundException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;

public class Main {
	// static LinkedList<ArrayList<map>> queue = new LinkedList<>();
	static Map<Integer, ArrayList<map>> vhcmap = new HashMap<>();
	public static Double MU = (double) 5;
	public static Map<Integer, Integer> real_locations = new HashMap<Integer, Integer>();
	public static Map<Integer, Integer> generated_locations = new HashMap<Integer, Integer>();


	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub
//		ArrayList<location> loc= new ArrayList<>();

//		/GPS-obscuration/data/location.txt
//		Scanner read = new Scanner (new File("./data/location.txt"));
//		   read.useDelimiter(" |\n");
//		   String lat, lon, t1,t2;
//		   int i=0;
//		   while(read.hasNext())
//		   {
//			 
//		       lat = read.next();
//		       lon = read.next();
//		       t1 = read.next();
//		       t2 = read.next();
//		     System.out.println(lat + " " + lon + "\n"); //just for debugging
//		     if(i<200) {
//		    	 loc.add(new location(Double.parseDouble(lat), Double.parseDouble(lon)));
//		    	 i++;
//		    	 }
//		     else break;
//		   }
//		   read.close();
//		   

//		int i=2;
//		int gridsize = 25;
//		int left = i-1% gridsize>=0?i-1:i;
//		int right = i+1% gridsize>=0?i+1:i;
//		int top = i-gridsize>=0?i-gridsize:i;
//		int bottom = i+gridsize<=gridsize*gridsize?i+gridsize:i;
//		int top_left = i-gridsize>=0 && i-1% gridsize>=0 ? i-gridsize-1:i;
//		int top_right = i-gridsize>=0 && i+1% gridsize>=0 ? i-gridsize+1:i;
//		int bottom_left = i+gridsize>=0 && i-1% gridsize>=0 ? i+gridsize-1:i;
//		int bottom_right = i+gridsize>=0 && i+1% gridsize>=0 ? i+gridsize+1:i;
//		System.out.println(left+" "+right+" "+top+" "+bottom+" "+top_left+" "+top_right+" "+bottom_left+" "+bottom_right);
		// new Main().spatialCloaking(loc);
		// new Main().noise(loc,50);
//		new Main().rounding(loc, 500);

//		ArrayList<map> marr = new ArrayList<Main.map>();
//		 Scanner read = new Scanner(new File("./data/maploc.txt"));
//		 while(read.hasNext()) {
//			 String text = read.nextLine();
//			 if(!text.equals("\n")){
//				 String id = text;
//				 String lat = read.nextLine();
//				 String lon = read.nextLine();
//				 System.out.println(id.trim());
//				 System.out.println(lat.trim());
//				 System.out.println(lon.trim());
//				 try {
//				 read.nextLine();
//				 }catch(Exception e) {
//					 
//				 }
//				 System.out.println();
//				 map m = new map();
//				 m.id = id;
//				 m.loc = new location(Double.valueOf(lat),Double.valueOf(lon));
//				 marr.add(m);
//			 }
//		 }
//		 read.close();

//		ArrayList<map> coordinates = new ArrayList<Main.map>();
//		coordinates.add(new map("0", new location(35.3123, -80.7432)));
//		coordinates.add(new map("0", new location(35.3123, -80.7199)));
//		coordinates.add(new map("0", new location(35.2945, -80.7199)));
//		coordinates.add(new map("0", new location(35.2945, -80.7432)));
		
		ArrayList<map> coordinates = new ArrayList<Main.map>();
		coordinates.add(new map("0", new location(40.0266, 116.1983)));
		coordinates.add(new map("0", new location(39.7563, 116.5478)));
		// queue.push(coordinates);

//		 vhc(marr, coordinates);

//		 System.out.println(vhcmap.size());
//		 System.out.println(marr);

//		 LinkedList<String> stack = new LinkedList<>();
//		 stack.push("hi");
//		 System.out.println(stack);
//		 stack.push("hello");
//		 System.out.println(stack);
//		 stack.push("how are you");
//		 System.out.println(stack);
//		 System.out.println(stack.pop());
//		 System.out.println(stack.pop());
//		 System.out.println(stack.pop());
		//(40.01187583333333, 116.3993125)	(39.97333555555556, 116.36008777777776)	(39.8913825, 116.2838975)	
		//(39.948130000000006, 116.40480777777776)	(40.003699999999995, 116.42973833333336)	(39.974757, 116.42792)
		//(39.98753153846154, 116.43026615384616)	(40.02314666666667, 116.51065666666666)	(39.95986, 116.37776333333333)
		//(39.949103333333326, 116.32815333333335)	(39.95498461538462, 116.30981615384613)	(39.955144000000004, 116.37717900000003)
		//(39.970014166666665, 116.46014499999997)	(39.96761, 116.457234)	(39.957902727272725, 116.44627454545456)	
		//(39.97113818181818, 116.3847390909091)	(39.93808083333333, 116.325015)	(39.94830166666666, 116.41040250000003)
		//(39.89901166666667, 116.46271499999999)	(39.86470500000001, 116.46611416666666)
		//(39.81478230769231, 116.47590307692309)	(39.89314083333333, 116.44828416666667)	(39.878412, 116.477145)
		//(39.89334090909092, 116.45336636363635)
		
//		ArrayList<LatLng> currentlocs = new ArrayList<LatLng>();
//		currentlocs.add(new LatLng(40.01187583333333, 116.3993125));
//		currentlocs.add(new LatLng(39.97333555555556, 116.36008777777776));
//		currentlocs.add(new LatLng(39.8913825, 116.2838975));
//		currentlocs.add(new LatLng(39.948130000000006, 116.40480777777776));
//		currentlocs.add(new LatLng(40.003699999999995, 116.42973833333336));
//		currentlocs.add(new LatLng(39.974757, 116.42792));
//		currentlocs.add(new LatLng(39.98753153846154, 116.43026615384616));
//		currentlocs.add(new LatLng(39.95986, 116.37776333333333));
//		currentlocs.add(new LatLng(39.949103333333326, 116.32815333333335));
//		currentlocs.add(new LatLng(39.95498461538462, 116.30981615384613));
//		currentlocs.add(new LatLng(39.955144000000004, 116.37717900000003));
//		currentlocs.add(new LatLng(39.970014166666665, 116.46014499999997));
//		currentlocs.add(new LatLng(39.96761, 116.457234));
//		currentlocs.add(new LatLng(39.957902727272725, 116.44627454545456));
//		currentlocs.add(new LatLng(39.97113818181818, 116.3847390909091));
//		currentlocs.add(new LatLng(39.93808083333333, 116.325015));
//		currentlocs.add(new LatLng(39.94830166666666, 116.41040250000003));
//		currentlocs.add(new LatLng(39.89901166666667, 116.46271499999999));
//		currentlocs.add(new LatLng(39.86470500000001, 116.46611416666666));
//		currentlocs.add(new LatLng(39.81478230769231, 116.47590307692309));
//		currentlocs.add(new LatLng(39.89314083333333, 116.44828416666667));
//		currentlocs.add(new LatLng(39.878412, 116.477145));
//		currentlocs.add(new LatLng(39.89334090909092, 116.45336636363635));

		int gridsize = 25;

		/*
		 *  lat_top_left = 40.0266
			lon_top_left = 116.1983
			lat_bottom_right = 39.7563
			lon_bottom_right = 116.5478
		 */
		// get the top left and bottom right coordinates
//		LatLng topleft = new LatLng(coordinates.get(0).loc.lat, coordinates.get(0).loc.lng);
//		LatLng bottomright = new LatLng(coordinates.get(1).loc.lat, coordinates.get(1).loc.lng);

		LatLng topleft = new LatLng(40.0266, 116.1983);
		LatLng bottomright = new LatLng(39.7563, 116.5478);
				
		// calculate the cell size
		double difflat = Math.abs(Math.toRadians(topleft.latitude) - Math.toRadians(bottomright.latitude));
		double difflng = Math.abs(Math.toRadians(topleft.longitude) - Math.toRadians(bottomright.longitude));
		double ans = Math.pow(Math.sin(difflat / 2), 2) + Math.cos(Math.toRadians(topleft.latitude))
				* Math.cos(Math.toRadians(bottomright.latitude)) * Math.pow(Math.sin(difflng / 2), 2);
		ans = 2 * Math.asin(Math.sqrt(ans));
		double brng = Math.atan2(difflat, -difflng);
		System.out.println("brng :"+brng);
		double radius = 6378137;
		System.out.println("distance : " + ans * radius / gridsize);
		double dim = ans * radius / gridsize;

		ArrayList<Integer> range = new ArrayList<Integer>();
		for (int i = 0; i < gridsize * gridsize; i++) {
			range.add(i);
			real_locations.put(i, 0);
			generated_locations.put(i, 0);
		}

		Map<Integer, ArrayList<LatLng>> grids = generateGrids(gridsize, dim, topleft);

		double probability = 0.025;
		
		System.out.println("output : "+ grids.get(624));

		//System.out.println("grids" + grids.toString());
		//System.out.println("range" + range);
//		System.out.println("Spotme result: " + dynamicSpotMe(grids, probability, new LatLng(35.3121, -80.7432), range));
		//System.out.println("Spotme result: " + dynamicSpotMe(grids, probability, currentlocs.get(0), range));
//		Map<Integer, Boolean> r = dynamicSpotMe(grids, 0.1, new LatLng(40.0266, 116.1983), range);
		System.out.println("initial probability:" + probability);
//		System.out.println("Spotme result: " + r);
		
//		ArrayList<Taxi> taxis = CSVReader.getTaxis();
//
//		for(int i=0;i<taxis.size();i++) {//taxis.size()
//			System.out.println("taxi_id: "+ taxis.get(i).taxi_id + "day: "+ taxis.get(i).day);
//			
//			ArrayList<LatLng> currentlocs = taxis.get(i).latLngs;
//			Map<Integer, Boolean> r = dynamicSpotMe(grids, probability, currentlocs.get(0), range);
//	
//			double current_probability = 0.0f;
//			for (int iteration = 1; iteration < currentlocs.size(); iteration++) {
//				//System.out.println("count : " + iteration);
//				ArrayList<Integer> newrange = generateExtendedMap(gridsize, r);
//				
//				int currentCell = getCurrentCell(grids,  currentlocs.get(iteration));
//				if(currentCell != -1) {
//					newrange.add(currentCell);
//				}
//				else {
//					System.out.println("out of bounds: " +currentlocs.get(iteration));
//					continue;
//				}
//				System.out.println("new range size "+ newrange.size());
//				current_probability = ((double) range.size() / (double) newrange.size()) * probability;
//				System.out.println("probability:" + current_probability);
//	//			r = dynamicSpotMe(grids, probability, new LatLng(40.0266, 116.1983), newrange);
//				r = dynamicSpotMe(grids, current_probability, currentlocs.get(iteration), newrange);
//	//			System.out.println("Spotme result: " + r);
//			}
//		}
//		
//		for(int i =0;i<gridsize * gridsize; i++) {
//			System.out.println("real : "+i+" "+ real_locations.get(i));
//			System.out.println("generated : "+i+" "+ generated_locations.get(i));
//		}
	}
	
	
	/*
	 * create two dict with one for reported and real data and update them when it is calculated
	 * and then calculate the RMSE
	 * 
	 * Use both spotme and dynamic spotme and compare the results
	 * 
	 * spotme Experiment and ds experiment 
	 * 
	 * parameters : probability, gridsize 
	 *  
	 */
	
	public static int getCurrentCell(Map<Integer, ArrayList<LatLng>> grids, LatLng current) {
		
		for(int i=0;i<grids.size();i++) {
			ArrayList<LatLng> locs = grids.get(i);
			if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
					&& locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
				return i;
			}
		}
		return -1;
	}

//																												^GoogleMap mMap
	public static Map<Integer, Boolean> dynamicSpotMe(Map<Integer, ArrayList<LatLng>> grids, double probability,
			LatLng current, ArrayList<Integer> range) {

		Map<Integer, Boolean> result = new HashMap<>();
		Random random = new Random();

		int count = 0;
		for (Integer r : range) {
			ArrayList<LatLng> locs = grids.get(r);
			if (random.nextDouble() < probability) {
				result.put(r, true);
				count++;
				generated_locations.replace(r, generated_locations.get(r)+1);

			} else {
				if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
						&& locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
					result.put(r, true);
					real_locations.replace(r, real_locations.get(r)+1);
					count++;
				} else {
					result.put(r, false);
				}
			}
		}
		System.out.println("result "+count);
		return result;
	}

	public static Map<Integer, ArrayList<LatLng>> generateGrids(int gridsize, double dim, LatLng topleft) {
		Map<Integer, ArrayList<LatLng>> grids = new HashMap<Integer, ArrayList<LatLng>>();
		double meters = dim;
		double radius = 6378137;
		double brng = 2.483288877600869;
		for (int i = 0; i < gridsize; i++) {
			for (int j = 0; j < gridsize; j++) {
				
				ArrayList<LatLng> arrayList = new ArrayList<LatLng>();

//				double coef = meters * 0.0000089;
//				double new_tlat = topleft.latitude - (i) * coef ;
//				double new_tlong = topleft.longitude + (j) * coef / Math.cos(topleft.latitude * 0.018);
//
//				arrayList.add(new LatLng(new_tlat, new_tlong));
//
//				double new_blat = topleft.latitude - (i + 1) * coef ;
//				double new_blong = topleft.longitude + (j + 1) * coef / Math.cos(topleft.latitude * 0.018);
//				
//				
//
//				lat1 = math.radians(52.20472) #Current lat point converted to radians
//				lon1 = math.radians(0.14056) #Current long point converted to radians
//				
//				lat2 = math.asin( math.sin(lat1)*math.cos(d/R) +
//				     math.cos(lat1)*math.sin(d/R)*math.cos(brng))
//				
//				lon2 = lon1 + math.atan2(math.sin(brng)*math.sin(d/R)*math.cos(lat1),
//				             math.cos(d/R)-math.sin(lat1)*math.sin(lat2))
//				
//				lat2 = math.degrees(lat2)
//				lon2 = math.degrees(lon2)
				
				
				
				double lat_t1 = Math.toRadians(topleft.latitude);
				double lon_t1 = Math.toRadians(topleft.longitude);
				
				double lat_t2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i))/radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i))/radius) *Math.cos(brng));
				
				double lon_t2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j))/radius)*Math.cos(lat_t1),
			             Math.cos((meters* (j))/radius)-Math.sin(lat_t1)*Math.sin(lat_t2));
				
				double new_tlat = Math.toDegrees(lat_t2);
				double new_tlong = Math.toDegrees(lon_t2);
				
				
				arrayList.add(new LatLng(new_tlat, new_tlong));
				
				
				
				double lat_b2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i+1))/radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i+1))/radius) *Math.cos(brng));
				
				double lon_b2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j+1))/radius)*Math.cos(lat_t1),
			             Math.cos((meters* (j+1))/radius)-Math.sin(lat_t1)*Math.sin(lat_b2));
				
				double new_blat = Math.toDegrees(lat_b2);
				double new_blong = Math.toDegrees(lon_b2);
				
				
				arrayList.add(new LatLng(new_blat, new_blong));
				grids.put(grids.size(), arrayList);
				//Log.d("demo", "spotMe: "+grids.get(grids.size()-1)+ " "+ (grids.size()-1));
			}

		}
		return grids;
	}
	
	// To - do add current location to extended map include in the range not to be extended
	
	public static ArrayList<Integer> generateExtendedMap(int gridsize, Map<Integer, Boolean> r) {
		ArrayList<Integer> newrange = new ArrayList<Integer>();
		for (Integer i : r.keySet()) {
			if (r.get(i) == true) {
				int left = (i - 1) % gridsize != gridsize - 1 && (i - 1) % gridsize >= 0 ? i - 1 : i;
				int right = (i + 1) % gridsize != 0 ? i + 1 : i;
				int top = i - gridsize >= 0 ? i - gridsize : i;
				int bottom = i + gridsize < gridsize * gridsize ? i + gridsize : i;
				int top_left = i - gridsize > 0 && (i - gridsize - 1) % gridsize != gridsize - 1 ? i - gridsize - 1 : i;
				int top_right = i - gridsize >= 0 && (i - gridsize + 1) % gridsize != 0 ? i - gridsize + 1 : i;
				int bottom_left = i + gridsize < gridsize * gridsize && (i + gridsize - 1) % gridsize != gridsize - 1
						? i + gridsize - 1
						: i;
				int bottom_right = i + gridsize < (gridsize * gridsize) - 1 && (i + gridsize + 1) % gridsize != 0
						? i + gridsize + 1
						: i;
				if (left != i) {
					newrange.add(left);
				}
				if (right != i) {
					newrange.add(right);
				}
				if (top != i) {
					newrange.add(top);
				}
				if (bottom != i) {
					newrange.add(bottom);
				}
				if (top_left != i) {
					newrange.add(top_left);
				}
				if (top_right != i) {
					newrange.add(top_right);
				}
				if (bottom_left != i) {
					newrange.add(bottom_left);
				}
				if (bottom_right != i) {
					newrange.add(bottom_right);
				}
				newrange.add(i);
				//System.out.println(left+" "+right+" "+top+" "+bottom+" "+top_left+" "+top_right+" "+bottom_left+" "+bottom_right);
			}
		}
		return newrange;
	}

	public ArrayList<location> spatialCloaking(ArrayList<location> loc) {
		//, location home
		ArrayList<location> newlocs = new ArrayList<Main.location>();
		for (location l : loc) {

			// System.out.println("home : "+home);
			System.out.println("location : " + l);
			Random rand = new Random();

			// offsets in meters
			double rlat = rand.nextInt(100);
			double rlng = rand.nextInt(100);

			System.out.println("r : " + rlat + " " + rlng);
			// Earth’s radius, sphere
			double earthR = 6378137;
			// Coordinate offsets in radians
			double dLat = rlat / earthR;
			// home
			double dLng = rlng / (earthR * Math.cos(Math.PI * l.lat / 180));

			location newCenter = new location();

			if (rand.nextGaussian() < 0.5) {
				dLat *= -1;
			}

			if (rand.nextGaussian() < 0.5) {
				dLng *= -1;
			}
			// OffsetPosition, decimal degrees
			// home
			newCenter.lat = l.lat + dLat * 180 / Math.PI;
			newCenter.lng = l.lng + dLng * 180 / Math.PI;
			newlocs.add(newCenter);
			System.out.println("new center within r : " + newCenter.toString());
		}

//		double newRlat = rlat + rand.nextInt(500);
//		double newRlng = rlng + rand.nextInt(500);
//		System.out.println("R : " + newRlat+" "+ newRlng);
//
//
//		double newDLat = newRlat/earthR;
//		double newDLng = newRlng/(earthR * Math.cos(Math.PI*newCenter.lat/180));
//
//		double RLat = newDLat *180/Math.PI;
//		double RLng = newDLng *180/Math.PI;
//
//		System.out.println("offset : "+RLat+" "+ RLng);
//
//		System.out.println();
//
//		System.out.println("before deletion:");
//		for(location l : loc) {
//			System.out.println(l);
//		}
//
//
//		Iterator<location> iterator = loc.iterator();
//		while(iterator.hasNext()) {
//			location l = iterator.next();
//			if((Math.abs(newCenter.lat - l.lat) < RLat) && (Math.abs(newCenter.lng - l.lng) < RLng)) {
//				iterator.remove();
//			}
//		}
//		System.out.println();
//		System.out.println("After deletion:");
		for (location l : newlocs) {
			System.out.println(l);
		}

		return newlocs;
	}

	public ArrayList<location> noise(ArrayList<location> locs, int variance) {

		System.out.println("locations :");
		for (location l : locs) {
			System.out.println(l);
		}

		Set<Main.location> newlocs = new HashSet<Main.location>();
		for (location l : locs) {
			Random rand = new Random();
			double noiseLat = rand.nextGaussian() * Math.sqrt(variance);
			double noiseLng = rand.nextGaussian() * Math.sqrt(variance);

			// offsets in meters
			double rlat = noiseLat;
			double rlng = noiseLng;

			// Earth’s radius, sphere
			double earthR = 6378137;
			// Coordinate offsets in radians
			double dLat = rlat / earthR;
			double dLng = rlng / (earthR * Math.cos(Math.PI * l.lat / 180));

			location newl0 = new location();
			// OffsetPosition, decimal degrees
			newl0.lat = l.lat + dLat * 180 / Math.PI;
			newl0.lng = l.lng + dLng * 180 / Math.PI;
			newlocs.add(newl0);

			location newl1 = new location();
			// OffsetPosition, decimal degrees
			newl1.lat = l.lat - dLat * 180 / Math.PI;
			newl1.lng = l.lng - dLng * 180 / Math.PI;
			newlocs.add(newl1);

			location newl2 = new location();
			// OffsetPosition, decimal degrees
			newl2.lat = l.lat - dLat * 180 / Math.PI;
			newl2.lng = l.lng + dLng * 180 / Math.PI;
			newlocs.add(newl2);

			location newl3 = new location();
			// OffsetPosition, decimal degrees
			newl3.lat = l.lat + dLat * 180 / Math.PI;
			newl3.lng = l.lng - dLng * 180 / Math.PI;
			newlocs.add(newl3);

		}

		// locs.addAll(newlocs);
		System.out.println();

		System.out.println("After adding noise:");
		for (location l : newlocs) {
			System.out.println(l);
		}

		System.out.println("total size: " + newlocs.size());
		return locs;
	}

	public ArrayList<location> rounding(ArrayList<location> locs, int delta) {

		Random rand = new Random();

		System.out.println("before rounding off locations:");
		for (location l : locs) {
			System.out.println(l);
		}
		System.out.println();
		double newRlat = delta;
		double newRlng = delta;
		System.out.println("delta : " + newRlat + " " + newRlng);

		// Earth’s radius, sphere
		double earthR = 6378137;

		for (location l : locs) {

			double newDLat = newRlat / earthR;
			double newDLng = newRlng / (earthR * Math.cos(Math.PI * l.lat / 180));

			double RLat = newDLat * 180 / Math.PI;
			double RLng = newDLng * 180 / Math.PI;

			if (rand.nextGaussian() < 0.5) {
				RLat *= -1;
			}

			if (rand.nextGaussian() < 0.5) {
				RLng *= -1;
			}

			location newl = new location();
			newl.lat = l.lat + RLat;
			newl.lng = l.lng + RLng;

			for (location l1 : locs) {
				if (!l1.equals(l)) {
					if (Math.abs(l1.lat - newl.lat) < Math.abs(l.lat - newl.lat)
							&& Math.abs(l1.lng - newl.lng) < Math.abs(l.lng - newl.lng)) {
						l1.lat = newl.lat;
						l1.lng = newl.lng;
					}

				} else {
					l1.lat = newl.lat;
					l1.lng = newl.lng;
				}
			}
		}

		for (location l : locs) {
			System.out.println(l);
		}
		return locs;
	}

	public static int vhc(ArrayList<map> m, ArrayList<map> coordinates2) {

		ArrayList<map> coordinates = coordinates2;
		map m1 = coordinates.get(0);
		map m2 = coordinates.get(1);
		map m3 = coordinates.get(2);
		map m4 = coordinates.get(3);

		double difflat = Math.abs(m1.loc.lat - m3.loc.lat);
		double difflng = Math.abs(m1.loc.lng - m3.loc.lng);

		double latmeters = difflat / 0.0000089;
		double lngmeters = difflng * Math.cos(m3.loc.lat * 0.018) / 0.0000089;

		int count = 0;
//		if(grids.get(i).latitude > current.latitude && grids.get(i+21).latitude < current.latitude && grids.get(i).longitude < current.longitude && grids.get(i+21).longitude > current.longitude) {
//      if (grids.get(i+1).latitude > current.latitude && grids.get(i + 22).latitude < current.latitude && grids.get(i+1).longitude > current.longitude && grids.get(i + 22).longitude > current.longitude) {

		for (int i = 0; i < m.size(); i++) {
			if (m1.loc.lat > m.get(i).loc.lat && m4.loc.lat < m.get(i).loc.lat && m1.loc.lng < m.get(i).loc.lng
					&& m4.loc.lng < m.get(i).loc.lng) {
				if (m2.loc.lat > m.get(i).loc.lat && m3.loc.lat < m.get(i).loc.lat && m2.loc.lng > m.get(i).loc.lng
						&& m3.loc.lng > m.get(i).loc.lng) {
					count++;
				}
			}

		}
		System.out.println(count + " " + MU * latmeters + " " + MU * lngmeters);

		if (count > 500) {// MU * latmeters && count > MU * lngmeters
			double lat = m1.loc.lat - Math.abs(m1.loc.lat - m3.loc.lat) / 2;
			double lng = m1.loc.lng + Math.abs(m1.loc.lng - m3.loc.lng) / 2;
			ArrayList<map> newcor1 = new ArrayList<Main.map>();
			map m12new = new map("" + 4, new location(m1.loc.lat, -1 * lng));
			map m13new = new map("" + 5, new location(lat, -1 * lng));
			map m14new = new map("" + 6, new location(lat, m1.loc.lng));
			newcor1.add(m1);
			newcor1.add(m12new);
			newcor1.add(m13new);
			newcor1.add(m14new);
			vhc(m, newcor1);

			ArrayList<map> newcor2 = new ArrayList<Main.map>();
			map m21new = new map("" + 4, new location(m1.loc.lat, -1 * lng));
			map m23new = new map("" + 5, new location(lat, m2.loc.lng));
			map m24new = new map("" + 6, new location(lat, -1 * lng));
			newcor2.add(m21new);
			newcor2.add(m2);
			newcor2.add(m23new);
			newcor2.add(m24new);
			vhc(m, newcor2);

			ArrayList<map> newcor3 = new ArrayList<Main.map>();
			map m31new = new map("" + 4, new location(lat, -1 * lng));
			map m32new = new map("" + 5, new location(lat, m3.loc.lng));
			map m34new = new map("" + 6, new location(m3.loc.lat, -1 * lng));
			newcor3.add(m31new);
			newcor3.add(m32new);
			newcor3.add(m3);
			newcor3.add(m34new);
			vhc(m, newcor3);

			ArrayList<map> newcor4 = new ArrayList<Main.map>();
			map m41new = new map("" + 4, new location(lat, m4.loc.lng));
			map m42new = new map("" + 5, new location(lat, -1 * lng));
			map m43new = new map("" + 6, new location(m4.loc.lat, -1 * lng));
			newcor4.add(m41new);
			newcor4.add(m42new);
			newcor4.add(m43new);
			newcor4.add(m4);
			vhc(m, newcor4);

//        	queue.push(coordinates);
//        	queue.push(newcor4);
//        	queue.push(newcor3);
//        	queue.push(newcor2);
//        	queue.push(newcor1);
//        	System.out.println(queue);

//        	if(queue.size()>0) {
//        		vhc(m);
//        	}

		} else {
			vhcmap.put(vhcmap.size(), coordinates);
			System.out.println(vhcmap);
			return 0;
//        if(queue.size()>0) {
//        		vhc(m);
//        }
//        else {
//        	return 0;
//        }
		}
		return 0;
	}

	static class location {
		Double lat;
		Double lng;

		public Double getLat() {
			return lat;
		}

		public void setLat(Double lat) {
			this.lat = lat;
		}

		public Double getLng() {
			return lng;
		}

		public void setLng(Double lng) {
			this.lng = lng;
		}

		public location(Double lat, Double lng) {
			super();
			this.lat = lat;
			this.lng = lng;
		}

		public location() {
			super();
		}

		@Override
		public String toString() {
			DecimalFormat ft = new DecimalFormat("####.########");
			// return "location [lat=" + ft.format(lat) + ", lng=" + ft.format(lng) + "]";
			return "[" + ft.format(lat) + ", " + ft.format(lng) + "]";
		}
	}

	static class map {
		String id;
		location loc;

		public map(String id, location loc) {
			super();
			this.id = id;
			this.loc = loc;
		}

		public map() {

		}

		@Override
		public String toString() {
			return "map [id=" + id + ", loc=" + loc + "]";
		}
	}
}
