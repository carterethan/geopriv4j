package geopriv4j;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import geopriv4j.utils.Constants;
import geopriv4j.utils.LatLng;

public class SpotMeAlgorithm {

	public static int gridSize = 25;
    public LatLng topleft = new LatLng(35.312266, -80.743184);
    public LatLng bottomright = new LatLng(35.2944838,-80.71985850859298);
    public static Map<Integer, ArrayList<LatLng>> grids = new HashMap<>();


    public SpotMeAlgorithm() {
        this.initiateSpotMe(topleft,  bottomright);
    }

    private void initiateSpotMe(LatLng topleft, LatLng bottomright){

        // calculate the cell size
        double difflat = Math.abs(Math.toRadians(topleft.latitude) - Math.toRadians(bottomright.latitude));
        double difflng = Math.abs(Math.toRadians(topleft.longitude) - Math.toRadians(bottomright.longitude));
        double result = Math.pow(Math.sin(difflat / 2), 2) + Math.cos(Math.toRadians(topleft.latitude))
                * Math.cos(Math.toRadians(bottomright.latitude)) * Math.pow(Math.sin(difflng / 2), 2);
        result = 2 * Math.asin(Math.sqrt(result));
        double offset = result * Constants.earth_radius / gridSize;
        
        //calculate bearing
		double y = Math.sin(Math.toRadians(bottomright.longitude) - Math.toRadians(topleft.longitude)) * Math.cos(Math.toRadians(bottomright.latitude));
		double x = Math.cos(Math.toRadians(topleft.latitude))*Math.sin(Math.toRadians(bottomright.latitude)) -
				Math.sin(Math.toRadians(topleft.latitude))*Math.cos(Math.toRadians(bottomright.latitude))
				*Math.cos(Math.toRadians(bottomright.longitude) - Math.toRadians(topleft.longitude));
		double brng = Math.atan2(y, x);

        generateGrids(offset, topleft, brng);

        
    }


    public static void generateGrids( double offset, LatLng topleft, double brng ) {
				
		double meters = offset;

		for (int i = 0; i < gridSize; i++) {
			for (int j = 0; j < gridSize; j++) {

				ArrayList<LatLng> arrayList = new ArrayList<LatLng>();

				double lat_t1 = Math.toRadians(topleft.latitude);
				double lon_t1 = Math.toRadians(topleft.longitude);

				double lat_t2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i))/Constants.earth_radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i))/Constants.earth_radius) *Math.cos(brng));

				double lon_t2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j))/Constants.earth_radius)*Math.cos(lat_t1),
						Math.cos((meters* (j))/Constants.earth_radius)-Math.sin(lat_t1)*Math.sin(lat_t2));

				double new_tlat = Math.toDegrees(lat_t2);
				double new_tlong = Math.toDegrees(lon_t2);


				arrayList.add(new LatLng(new_tlat, new_tlong));

				double lat_b2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i+1))/Constants.earth_radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i+1))/Constants.earth_radius) *Math.cos(brng));

				double lon_b2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j+1))/Constants.earth_radius)*Math.cos(lat_t1),
						Math.cos((meters* (j+1))/Constants.earth_radius)-Math.sin(lat_t1)*Math.sin(lat_b2));

				double new_blat = Math.toDegrees(lat_b2);
				double new_blong = Math.toDegrees(lon_b2);

				arrayList.add(new LatLng(new_blat, new_blong));
				grids.put(grids.size(), arrayList);
			}

		}
	}

    public static Map<Integer, Boolean> generate( double probability, LatLng current) {

        Map<Integer, Boolean> result = new HashMap<>();
        Random random = new Random();

        int count = 0;
        for (Integer r =0 ; r< grids.size();r++) {
            ArrayList<LatLng> locs = grids.get(r);
            if (random.nextDouble() < probability) {
                result.put(r, true);
                count++;

            } else {
                if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
                        && locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
                    result.put(r, true);
                    count++;
                } else {
                    result.put(r, false);
                }
            }
        }
        System.out.println("result "+count);
        System.out.println("result "+result);
        return result;
    }
}
