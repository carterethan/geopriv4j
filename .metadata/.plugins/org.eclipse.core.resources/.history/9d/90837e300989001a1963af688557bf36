package algorithms;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;



import algorithms.LatLng;

public class DynamicSpotMe {
	//Earthâ€™s radius, sphere
	final public static int earth_radius = 6378137;
	//specify the grid size 
	public static int gridSize = 25;

	//This contains the grids that is generated
    public static Map<Integer, ArrayList<LatLng>> grids = new HashMap<>();
    
    static ArrayList<Integer> real_locs =  new ArrayList<Integer>();
    static ArrayList<Integer> generated_locs =  new ArrayList<Integer>();


    
    
    /*
     * lat_top_left = 40.0266
	lon_top_left = 116.1983
	lat_bottom_right = 39.7563
	lon_bottom_right = 116.5478
     */
    //speicfy the topleft and the bottomright locations for the grid 
    public LatLng topleft = new LatLng(40.0266, 116.1983);
    public LatLng bottomright = new LatLng(39.7563,116.5478);


    public DynamicSpotMe() {
        this.initiateDynamicSpotMe(topleft,  bottomright);
    }
    
    

    //created the grid by calculating the cell size and bearing
    private void initiateDynamicSpotMe(LatLng topleft, LatLng bottomright){

        // calculate the cell size
        double difflat = Math.abs(Math.toRadians(topleft.latitude) - Math.toRadians(bottomright.latitude));
        double difflng = Math.abs(Math.toRadians(topleft.longitude) - Math.toRadians(bottomright.longitude));
        double result = Math.pow(Math.sin(difflat / 2), 2) + Math.cos(Math.toRadians(topleft.latitude))
                * Math.cos(Math.toRadians(bottomright.latitude)) * Math.pow(Math.sin(difflng / 2), 2);
        result = 2 * Math.asin(Math.sqrt(result));
        double offset = result * earth_radius / gridSize;
        
        //calculate bearing
		double y = Math.sin(Math.toRadians(bottomright.longitude) - Math.toRadians(topleft.longitude)) * Math.cos(Math.toRadians(bottomright.latitude));
		double x = Math.cos(Math.toRadians(topleft.latitude))*Math.sin(Math.toRadians(bottomright.latitude)) -
				Math.sin(Math.toRadians(topleft.latitude))*Math.cos(Math.toRadians(bottomright.latitude))
				*Math.cos(Math.toRadians(bottomright.longitude) - Math.toRadians(topleft.longitude));
		double brng = Math.atan2(y, x);

        generateGrids(offset, topleft, brng);
        
    }

    //generates the grid based on the specified gridsize and the topleft location
    public static void generateGrids( double offset, LatLng topleft, double brng ) {
				
		double meters = offset;

		for (int i = 0; i < gridSize; i++) {
			for (int j = 0; j < gridSize; j++) {

				ArrayList<LatLng> arrayList = new ArrayList<LatLng>();
				
				//calculate the top left location for each cell 
				
				//convert to radians
				double lat_t1 = Math.toRadians(topleft.latitude);
				double lon_t1 = Math.toRadians(topleft.longitude);
				
				//calculate the new lcations 
				double lat_t2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i))/earth_radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i))/earth_radius) *Math.cos(brng));

				double lon_t2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j))/earth_radius)*Math.cos(lat_t1),
						Math.cos((meters* (j))/earth_radius)-Math.sin(lat_t1)*Math.sin(lat_t2));
				
				//convert back to degrees
				double new_tlat = Math.toDegrees(lat_t2);
				double new_tlong = Math.toDegrees(lon_t2);


				arrayList.add(new LatLng(new_tlat, new_tlong));

				//calculate the bottom right location for each cell 
				
				//calculate new location
				double lat_b2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i+1))/earth_radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i+1))/earth_radius) *Math.cos(brng));

				double lon_b2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j+1))/earth_radius)*Math.cos(lat_t1),
						Math.cos((meters* (j+1))/earth_radius)-Math.sin(lat_t1)*Math.sin(lat_b2));
				
				//convert back to degrees
				double new_blat = Math.toDegrees(lat_b2);
				double new_blong = Math.toDegrees(lon_b2);

				arrayList.add(new LatLng(new_blat, new_blong));
				
				//adding both topleft and bottom right to specified cell in the grid
				grids.put(grids.size(), arrayList);
			}

		}
	}
    
    //this generates new locations based on the current location and specified probability
    public static Map<Integer, Boolean> generate( LatLng current, double probability, ArrayList<Integer> range) {

        Map<Integer, Boolean> result = new HashMap<>();
        Random random = new Random();

        int count = 0;
        
        for (Integer r : range) {
            ArrayList<LatLng> locs = grids.get(r);
//            System.out.println(locs);
            
            //check if the probability is greater then report true
            if (random.nextDouble() < probability) {
                result.put(r, true);
                count++;
                generated_locs.set(r , generated_locs.get(r)+1);

            } else {
            	//check if current user location is in the cell then report true
                if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
                        && locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
                    result.put(r, true);
                    count++;
                } 
                //report false if not
                else {
                    result.put(r, false);
                }
            }
        }
//        System.out.println("reported count "+count);
        return result;
    }
    
    public static ArrayList<Integer> extendedMap(ArrayList<Integer> range){
    	
    	ArrayList<Integer> extendedMapList = new ArrayList<Integer>();
    	for(int r : range) {
//    		System.out.println(r + " " + gridSize);
    		int left = r % gridSize == 0 ? -1: r-1; 
    		int right = (r+1) % gridSize == 0 ? -1: r+1;
    		int top = (r-gridSize) < 0 ? -1: r-gridSize;
    		int bottom = (r+gridSize) > (gridSize*gridSize-1) ? -1 : r+gridSize;
    		int topLeft = (r-gridSize) < 0 | r % gridSize == 0 ? -1: r-gridSize-1;
    		int topRight = (r-gridSize) < 0 | (r+1 % gridSize) == 0 ? -1: r-gridSize+1;
    		int bottomLeft = (r+gridSize) > (gridSize*gridSize-1) | r % gridSize == 0 ? -1: r+gridSize-1;
    		int bottomRight = (r+gridSize) > (gridSize*gridSize-1) | ((r+1) % gridSize) == 0 ? -1: r+gridSize+1;
    		
//    		System.out.println(left+" "+right+" "+top+" "+bottom+" "+topLeft+" "+topRight+" "+bottomLeft+" "+bottomRight);
    		
    		if(left!=-1) {
    			extendedMapList.add(left);
    		}
    		if(right!=-1) {
    			extendedMapList.add(right);
    		}
    		if(top!=-1) {
    			extendedMapList.add(top);
    		}
    		if(bottom!=-1) {
    			extendedMapList.add(bottom);
    		}
    		if(topLeft!=-1) {
    			extendedMapList.add(topLeft);
    		}
    		if(topRight!=-1) {
    			extendedMapList.add(topRight);
    		}
    		if(bottomLeft!=-1) {
    			extendedMapList.add(bottomLeft);
    		}
    		if(bottomRight!=-1) {
    			extendedMapList.add(bottomRight);
    		}
    		
    		extendedMapList.add(r);
    	}
    	
    	return extendedMapList;
    }
    
    public static ArrayList<Integer> initialize(){
    	ArrayList<Integer> range = new ArrayList<Integer>();
    	for(int i=0;i<gridSize*gridSize;i++) {
    		range.add(i);
    		real_locs.add(0);
    		generated_locs.add(0);
    	}
    	return range;
    }
    
    public static int getCurrentCell(LatLng current) {
    	if(current.latitude!=0 && current.latitude!=-1) {
	    	for (Integer r =0 ; r< grids.size();r++) {
	            ArrayList<LatLng> locs = grids.get(r);
	            	//check if current user location is in the cell then report true
	                if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
	                        && locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
	                	return r;
	                } 
	    	}
	    	return -1;
    	}
    	else {
    		return -1;
    	}
    }
    
    public static ArrayList<Integer> getReportedCells(Map<Integer, Boolean> reported) {
    	ArrayList<Integer> reportedCells = new ArrayList<Integer>();
    	for(int i : reported.keySet()) {
    		if (reported.get(i)==true) {
    			reportedCells.add(i);	
    		}
    	}
    	return reportedCells;
    }
    
    public  void computeDynamicSpotMe(Taxi  taxi, double probability, ArrayList<Integer> range) {
    	
    	boolean flag = false;
    	Map<Integer, Boolean> reported = null;
    	double probability_computed=0;
    	ArrayList<Integer> reportedCells =null;
    	for(LatLng latLng: taxi.locations) {
    		int cell = getCurrentCell(latLng);
    		if(!flag) {
    			
    			if ( cell!= -1) {
    				real_locs.set(cell,real_locs.get(cell)+1);
    				reported = generate(latLng, probability, range);
    				flag=true;
    			}
    			else {
//    				System.out.println("user out of range initital");
    			}
    		}
    		else {
//    			System.out.println(reported);
    			
    			
    				reportedCells = extendedMap(getReportedCells(reported));
    				if (cell != -1) {
    					reportedCells.add(cell);
    				}
    				else {
//        				System.out.println("user out of range");
        			}
    				probability_computed= ((double)range.size()/(double)reportedCells.size())*probability;
//    				System.out.println(probability_computed);
        			reported = generate(latLng, probability_computed, reportedCells);
    			}
    			
//    			System.out.println(getReportedCells(reported).size());
		}
	}
   
    public static void evaluate() {
    	ArrayList<Double>real_locations = normalize(real_locs);
    	ArrayList<Double>generated_locations = normalize(generated_locs);
    	
    	double fn = 0;
    	for(int i=0;i<gridSize*gridSize;i++) {
    		fn+= Math.pow((real_locations.get(i)-generated_locations.get(i))/(real_locations.get(i)+ 1),2);
    	}
    	double error = Math.sqrt(fn/(gridSize*gridSize));
    	System.out.println("RMSE: "+error);
    }
    
    public static ArrayList<Double> normalize(ArrayList<Integer>locs) {
    	double sum=0;
    	ArrayList<Double> normalized = new ArrayList<Double>();
    	for(int i=0;i<gridSize*gridSize;i++) {
    		sum += locs.get(i);
    	}
    	
    	for(int i=0;i<gridSize*gridSize;i++) {
    		normalized.add(i, locs.get(i)/sum);
    	}
    	return normalized;
    }
    
    public static void main(String[] args) {
//    	
//    	//specify the probability for reporting true
//    	 double probability = 0.01;
//    	 
//    	//this is the current user location
// 		LatLng current_loc = new LatLng(35.3123,-80.7432);
// 		
// 		DynamicSpotMe algorithm = new DynamicSpotMe();
// 		Map<Integer, Boolean> reported_locations = algorithm.generate(current_loc, probability);
// 		
// 		System.out.println("reported locations: "+ reported_locations);

    	ArrayList<Taxi>taxis = TaxiFileReader.readFile("src/data/result.csv");
    	double probability =0.04;
    	ArrayList<Integer> range = initialize();//(ArrayList<Integer>) IntStream.rangeClosed(0, gridSize*gridSize-1).boxed().collect(Collectors.toList());
    	for(int i =0;i<taxis.size();i++) {
    		Taxi taxi = taxis.get(i);
//    		System.out.println(taxi.taxi_id+" "+taxi.day);
    		new DynamicSpotMe().computeDynamicSpotMe(taxi, probability, range);
    	}
    	evaluate();	
    } 
}
