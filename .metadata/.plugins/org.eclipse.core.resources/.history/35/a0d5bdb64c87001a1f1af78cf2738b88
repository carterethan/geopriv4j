package geopriv4j;

/*
 * In this we use Various-size-grid Hilbert Curve (VHC)-mapping to project user location 
 * based on the population density in each cell.
 * 
 * This has been implemented based on the paper by Pingley, Aniket, et al. 
 * "Cap: A context-aware privacy protection system for location-based services." 
 * 2009 29th IEEE International Conference on Distributed Computing Systems. IEEE, 2009.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

import geopriv4j.utils.Constants;
import geopriv4j.utils.LatLng;
import geopriv4j.utils.Mapper;
import geopriv4j.utils.VhcFileReader;

public class VHCAlgorithm {
	
	public static Map<Integer,ArrayList<Mapper>> vhcmap = new HashMap<>();
    public static Mapper topleft = new Mapper("topleft",new LatLng(35.3123,-80.7432));
    public static Mapper topright = new Mapper("topright",new LatLng(35.3123,-80.7199));
    public static Mapper bottomright = new Mapper("bottomright",new LatLng(35.2945,-80.7199));
    public static Mapper bottomleft = new Mapper("bottomleft",new LatLng(35.2945,-80.7432));


    public VHCAlgorithm() {
    	
        ArrayList<Mapper> mappers = VhcFileReader.readFile();
        ArrayList<Mapper> coordinates = new ArrayList<>();
        coordinates.add(topleft);
        coordinates.add(topright);
        coordinates.add(bottomright);
        coordinates.add(bottomleft);
        initiateVhc(mappers,coordinates);

    }

    public static int initiateVhc(ArrayList<Mapper> mappers, ArrayList<Mapper> coordinates) {

        Mapper topleftMap = coordinates.get(0);
        Mapper toprightMap = coordinates.get(1);
        Mapper bottomrightMap = coordinates.get(2);
        Mapper bottomleftMap = coordinates.get(3);


//        double diff_in_lat = Math.abs(topleftMap.loc.latitude - bottomrightMap.loc.latitude);
//        double diff_in_lng = Math.abs(topleftMap.loc.longitude - bottomrightMap.loc.longitude);

//        double latmeters = difflat/0.0000089;
//        double lngmeters = difflng * Math.cos(m3.loc.latitude * 0.018)/0.0000089;

        int count = 0;

        for(int i=0;i<mappers.size();i++) {
            if(topleftMap.loc.latitude > mappers.get(i).loc.latitude && Math.abs(topleftMap.loc.longitude) > Math.abs(mappers.get(i).loc.longitude) ) {//&&  m4.loc.longitude < m.get(i).loc.longitude  &&  m4.loc.latitude < m.get(i).loc.latitude
                if(bottomrightMap.loc.latitude < mappers.get(i).loc.latitude && Math.abs(bottomrightMap.loc.longitude) < Math.abs(mappers.get(i).loc.longitude) ) {//&&  m3.loc.longitude >m.get(i).loc.longitude  &&  m2.loc.latitude > m.get(i).loc.latitude
                    count++;
                }
            }
        }

        if(count > Constants.VHC_LIMIT ) {// MU * latmeters && count > MU * lngmeters
            double lat = topleftMap.loc.latitude - (Math.abs(topleftMap.loc.latitude) - Math.abs(bottomrightMap.loc.latitude))/2;
            double lng = topleftMap.loc.longitude + (Math.abs(topleftMap.loc.longitude) - Math.abs(bottomrightMap.loc.longitude))/2;
            
            ArrayList <Mapper> topLeftSquare_coordinates = new ArrayList<Mapper>();
            
            Mapper new_TLS_toprightMap = new Mapper("TLS_toprightMap", new LatLng(topleftMap.loc.latitude,lng));
            Mapper new_TLS_bottomrightMap = new Mapper("TLS_bottomrightMap", new LatLng(lat,lng));
            Mapper new_TLS_bottomleftMap = new Mapper("TLS_bottomleftMap", new LatLng(lat,topleftMap.loc.longitude));
            topLeftSquare_coordinates.add(topleftMap);
            topLeftSquare_coordinates.add(new_TLS_toprightMap);
            topLeftSquare_coordinates.add(new_TLS_bottomrightMap);
            topLeftSquare_coordinates.add(new_TLS_bottomleftMap);
            initiateVhc(mappers,topLeftSquare_coordinates);

            ArrayList<Mapper> topRightSquare_coordinates = new ArrayList<Mapper>();
            Mapper new_TRS_topleftMap = new Mapper("TRS_topleftMap", new LatLng(topleftMap.loc.latitude,lng));
            Mapper new_TRS_bottomrightMap = new Mapper("TRS_bottomrightMap", new LatLng(lat,toprightMap.loc.longitude));
            Mapper new_TRS_bottomleftMap = new Mapper("TRS_bottomleftMap", new LatLng(lat,lng));
            topRightSquare_coordinates.add(new_TRS_topleftMap);
            topRightSquare_coordinates.add(toprightMap);
            topRightSquare_coordinates.add(new_TRS_bottomrightMap);
            topRightSquare_coordinates.add(new_TRS_bottomleftMap);
            initiateVhc(mappers,topRightSquare_coordinates);

            ArrayList<Mapper> bottomRightSquare_coordinates = new ArrayList<Mapper>();
            Mapper new_BRS_topleftMap = new Mapper("BRS_topleftMap", new LatLng(lat,lng));
            Mapper new_BRS_toprightMap = new Mapper("BRS_toprightMap", new LatLng(lat,bottomrightMap.loc.longitude));
            Mapper new_BRS_bottomleftMap = new Mapper("BRS_bottomleftMap", new LatLng(bottomrightMap.loc.latitude,lng));
            bottomRightSquare_coordinates.add(new_BRS_topleftMap);
            bottomRightSquare_coordinates.add(new_BRS_toprightMap);
            bottomRightSquare_coordinates.add(bottomrightMap);
            bottomRightSquare_coordinates.add(new_BRS_bottomleftMap);
            initiateVhc(mappers,bottomRightSquare_coordinates);

            ArrayList<Mapper> bottomLeftSquare_coordinates = new ArrayList<Mapper>();
            Mapper new_BLS_topleftMap = new Mapper("BLS_topleftMap", new LatLng(lat,bottomleftMap.loc.longitude));
            Mapper new_BLS_toprightMap = new Mapper("BLS_toprightMap", new LatLng(lat,lng));
            Mapper new_BLS_bottomrightMap = new Mapper("BLS_bottomrightMap", new LatLng(bottomleftMap.loc.latitude,lng));
            bottomLeftSquare_coordinates.add(new_BLS_topleftMap);
            bottomLeftSquare_coordinates.add(new_BLS_toprightMap);
            bottomLeftSquare_coordinates.add(new_BLS_bottomrightMap);
            bottomLeftSquare_coordinates.add(bottomleftMap);
            initiateVhc(mappers,bottomLeftSquare_coordinates);

        }
        else {
            vhcmap.put(vhcmap.size(), coordinates);
            return 0;
        }
        return 0;
    }

    public static LatLng generate(Mapper mapper , int windowSize) {
        Random random = new Random();
        int result=0;
        int sign = 1;

        if(random.nextGaussian()<0.5){
            sign*=-1;
        }

        for(int i=0;i<vhcmap.size();i++){
            ArrayList<Mapper> coordinates = vhcmap.get(i);
            Mapper topleftMap = coordinates.get(0);
            Mapper bottomrightMap = coordinates.get(2);
            if(topleftMap.loc.latitude > mapper.loc.latitude && Math.abs(topleftMap.loc.longitude) > Math.abs(mapper.loc.longitude) ) {
                if(bottomrightMap.loc.latitude < mapper.loc.latitude && Math.abs(bottomrightMap.loc.longitude) < Math.abs(mapper.loc.longitude) ) {
                    result = i+sign*random.nextInt(windowSize);
                }
            }
        }
        if(result>=vhcmap.size()) {
            ArrayList<Mapper> coordinates = vhcmap.get(vhcmap.size());
            Mapper topleftMap = coordinates.get(0);
            Mapper bottomrightMap = coordinates.get(2);
            double lat = topleftMap.loc.latitude - (Math.abs(topleftMap.loc.latitude) - Math.abs(bottomrightMap.loc.latitude))/2;
            double lng = topleftMap.loc.longitude + (Math.abs(topleftMap.loc.longitude) - Math.abs(bottomrightMap.loc.longitude))/2;
            return new LatLng(lat,lng);
        }
        if(result<=0) {
            ArrayList<Mapper> coordinates = vhcmap.get(0);
            Mapper topleftMap = coordinates.get(0);
            Mapper bottomrightMap = coordinates.get(2);
            double lat = topleftMap.loc.latitude - (Math.abs(topleftMap.loc.latitude) - Math.abs(bottomrightMap.loc.latitude))/2;
            double lng = topleftMap.loc.longitude + (Math.abs(topleftMap.loc.longitude) - Math.abs(bottomrightMap.loc.longitude))/2;
            return new LatLng(lat,lng);
        }
        else{
            ArrayList<Mapper> coordinates = vhcmap.get(result);
            Mapper topleftMap = coordinates.get(0);
            Mapper bottomrightMap = coordinates.get(2);
            double lat = topleftMap.loc.latitude - (Math.abs(topleftMap.loc.latitude) - Math.abs(bottomrightMap.loc.latitude))/2;
            double lng = topleftMap.loc.longitude + (Math.abs(topleftMap.loc.longitude) - Math.abs(bottomrightMap.loc.longitude))/2;
            return new LatLng(lat,lng);
        }
    }


 
}
