import java.io.File;
import java.io.FileNotFoundException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;

public class Main {
	static Map<Integer, ArrayList<map>> vhcmap = new HashMap<>();
	public static Double MU = (double) 5;
	public static Map<Integer, Integer> real_locations = new HashMap<Integer, Integer>();
	public static Map<Integer, Integer> generated_locations = new HashMap<Integer, Integer>();
	public static Map<Integer, Integer> real_locations_dynamic = new HashMap<Integer, Integer>();
	public static Map<Integer, Integer> generated_locations_dynamic = new HashMap<Integer, Integer>();


	public static void main(String[] args) throws FileNotFoundException {
		// TODO Auto-generated method stub

		int gridsize = 25;
		double probability = 0.025;// 0.05, 0.1, 0.2.....

		LatLng topleft = new LatLng(40.0266, 116.1983);
		LatLng bottomright = new LatLng(39.7563, 116.5478);

		ArrayList<Integer> range = new ArrayList<Integer>();
		for (int i = 0; i < gridsize * gridsize; i++) {
			range.add(i);
			real_locations.put(i, 0);
			generated_locations.put(i, 0);
			real_locations_dynamic.put(i, 0);
			generated_locations_dynamic.put(i, 0);
		}

		Map<Integer, ArrayList<LatLng>> grids =initiateGrids( gridsize,  topleft,  bottomright);

		ArrayList<Taxi> taxis = CSVReader.getTaxis();

		for(int i=0;i<taxis.size();i++) {

			initiateDynamicSpotme(taxis.get(i), grids,  probability, range,  gridsize);
		}

		for(int i=0;i<taxis.size();i++) {
			initiateSpotme(taxis.get(i), grids,  probability, range,  gridsize);
		}

		evaluate(gridsize);
	}

	
	/*
	 * probabilities or probability distribution for each cell using normalization
	 * 
	 * modularize the code
	 */ 
	
	public static void evaluate(int gridsize) {
		
		int sum_dynamic = 0;
		int sum_spotme = 0;
		
		normalize( gridsize);
		
		for(int i = 0; i < gridsize * gridsize; i++) {
			System.out.println("real cell " + i + " : " + real_locations.get(i));
			System.out.println("generated cell " + i + " : " + generated_locations.get(i));

			sum_spotme += Math.pow((real_locations.get(i) - generated_locations.get(i)) / real_locations.get(i), 2);

			System.out.println("real dynamic cell " + i + " : " + real_locations_dynamic.get(i));
			System.out.println("generated dynamic cell " + i + " : " + generated_locations_dynamic.get(i));

			sum_dynamic += Math.pow((real_locations_dynamic.get(i) - generated_locations_dynamic.get(i)) / real_locations_dynamic.get(i), 2);
			System.out.println();
		}
		double error_spotme = Math.sqrt(sum_spotme / (gridsize * gridsize));
		System.out.println("RMSE error SpotMe : " + error_spotme);
		System.out.println();
		double error_dynamicspotme = Math.sqrt(sum_dynamic / (gridsize * gridsize));
		System.out.println("RMSE error Dynamic SpotMe : " + error_dynamicspotme);
	}
	
	public static void normalize(int gridsize) {
		
		int sum_real = 0;
		int sum_dynamic_real = 0;
		int sum_generated = 0;
		int sum__dynamic_generated = 0;
		
		for (int i = 0; i<gridsize * gridsize; i++) {
			 sum_real += real_locations.get(i);
			 sum_dynamic_real += real_locations_dynamic.get(i);
			 sum_generated += generated_locations.get(i);
			 sum__dynamic_generated += generated_locations_dynamic.get(i);
		}
		
		for (int i = 0; i<gridsize * gridsize; i++) {
			 real_locations.replace(i, real_locations.get(i)/ sum_real);
			 real_locations_dynamic.replace(i, real_locations_dynamic.get(i)/sum_dynamic_real);
			 generated_locations.replace(i, generated_locations.get(i)/sum_generated);
			 generated_locations_dynamic.replace(i, generated_locations_dynamic.get(i)/sum__dynamic_generated);
		}
		
	}
	
	public static void initiateDynamicSpotme(Taxi taxi, Map<Integer, ArrayList<LatLng>> grids, double probability, ArrayList<Integer> range, int gridsize)
	{
		ArrayList<LatLng> currentlocs = taxi.latLngs;
		Map<Integer, Boolean> r = new HashMap<Integer, Boolean>();

		boolean flag = false;
		double current_probability = 0.0f;
		for (int iteration = 0; iteration < currentlocs.size(); iteration++) {
			if(!flag) {
				int firstcell = getCurrentCell(grids,  currentlocs.get(iteration));
				if(firstcell != -1) {
					real_locations_dynamic.replace(firstcell, real_locations_dynamic.get(firstcell)+1);
					r = dynamicSpotMe(grids, probability, currentlocs.get(iteration), range);
					flag=true;
				}
			}
			else {
				ArrayList<Integer> newrange = generateExtendedMap(gridsize, r);

				int currentCell = getCurrentCell(grids,  currentlocs.get(iteration));
				if(currentCell != -1) {
					real_locations_dynamic.replace(currentCell, real_locations_dynamic.get(currentCell)+1);
					newrange.add(currentCell);
				}
				else {
					continue;
				}
				current_probability = ((double) range.size() / (double) newrange.size()) * probability;

				r = dynamicSpotMe(grids, current_probability, currentlocs.get(iteration), newrange);
			}
			
		}
	}

	public static void initiateSpotme(Taxi taxi, Map<Integer, ArrayList<LatLng>> grids, double probability, ArrayList<Integer> range, int gridsize)
	{
		ArrayList<LatLng> currentlocs = taxi.latLngs;
		Map<Integer, Boolean> r = new HashMap<Integer, Boolean>(); 

		for (int iteration = 0; iteration < currentlocs.size(); iteration++) {
			int currentCell = getCurrentCell(grids,  currentlocs.get(iteration));
			if(currentCell != -1) {
				real_locations.replace(currentCell, real_locations.get(currentCell)+1);
			}
			else {
				continue;
			}
			r = SpotMe(grids, probability, currentlocs.get(iteration));
		}
	}
	
	private static Map<Integer,ArrayList<LatLng>> initiateGrids(int gridSize, LatLng topleft, LatLng bottomright){
		int gridsize = gridSize;


		// calculate the cell size
		double difflat = Math.abs(Math.toRadians(topleft.latitude) - Math.toRadians(bottomright.latitude));
		double difflng = Math.abs(Math.toRadians(topleft.longitude) - Math.toRadians(bottomright.longitude));
		double ans = Math.pow(Math.sin(difflat / 2), 2) + Math.cos(Math.toRadians(topleft.latitude))
		* Math.cos(Math.toRadians(bottomright.latitude)) * Math.pow(Math.sin(difflng / 2), 2);
		ans = 2 * Math.asin(Math.sqrt(ans));
		double radius = 6378137;//6371000;
		double dim = ans * radius / gridsize;



		double y = Math.sin(Math.toRadians(bottomright.longitude) - Math.toRadians(topleft.longitude)) * Math.cos(Math.toRadians(bottomright.latitude));
		double x = Math.cos(Math.toRadians(topleft.latitude))*Math.sin(Math.toRadians(bottomright.latitude)) -
				Math.sin(Math.toRadians(topleft.latitude))*Math.cos(Math.toRadians(bottomright.latitude))
				*Math.cos(Math.toRadians(bottomright.longitude) - Math.toRadians(topleft.longitude));
		double brng = Math.atan2(y, x);

		Map<Integer,ArrayList<LatLng>> grids = generateGrids(gridsize, dim, topleft, brng);
		return grids;
	}


	public static int getCurrentCell(Map<Integer, ArrayList<LatLng>> grids, LatLng current) {

		for(int i=0;i<grids.size();i++) {
			ArrayList<LatLng> locs = grids.get(i);
			if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
					&& locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
				return i;
			}
		}
		return -1;
	}

	public static Map<Integer, Boolean> dynamicSpotMe(Map<Integer, ArrayList<LatLng>> grids, double probability,
			LatLng current, ArrayList<Integer> range) {

		Map<Integer, Boolean> result = new HashMap<>();
		Random random = new Random();

		int count = 0;
		for (Integer r : range) {
			ArrayList<LatLng> locs = grids.get(r);
			if (random.nextDouble() < probability) {
				result.put(r, true);
				count++;
				generated_locations_dynamic.replace(r, generated_locations_dynamic.get(r)+1);

			} else {
				if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
						&& locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
					result.put(r, true);
					count++;
				} else {
					result.put(r, false);
				}
			}
		}
		return result;
	}

	public static Map<Integer, ArrayList<LatLng>> generateGrids(int gridsize, double dim, LatLng topleft, double brng ) {
		Map<Integer, ArrayList<LatLng>> grids = new HashMap<Integer, ArrayList<LatLng>>();
		double meters = dim;
		double radius = 6378137;
		for (int i = 0; i < gridsize; i++) {
			for (int j = 0; j < gridsize; j++) {

				ArrayList<LatLng> arrayList = new ArrayList<LatLng>();

				double lat_t1 = Math.toRadians(topleft.latitude);
				double lon_t1 = Math.toRadians(topleft.longitude);

				double lat_t2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i))/radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i))/radius) *Math.cos(brng));

				double lon_t2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j))/radius)*Math.cos(lat_t1),
						Math.cos((meters* (j))/radius)-Math.sin(lat_t1)*Math.sin(lat_t2));

				double new_tlat = Math.toDegrees(lat_t2);
				double new_tlong = Math.toDegrees(lon_t2);


				arrayList.add(new LatLng(new_tlat, new_tlong));

				double lat_b2 = Math.asin(Math.sin(lat_t1)* Math.cos((meters* (i+1))/radius) +
						Math.cos(lat_t1)* Math.sin((meters* (i+1))/radius) *Math.cos(brng));

				double lon_b2 = lon_t1 + Math.atan2(Math.sin(brng)* Math.sin((meters* (j+1))/radius)*Math.cos(lat_t1),
						Math.cos((meters* (j+1))/radius)-Math.sin(lat_t1)*Math.sin(lat_b2));

				double new_blat = Math.toDegrees(lat_b2);
				double new_blong = Math.toDegrees(lon_b2);


				arrayList.add(new LatLng(new_blat, new_blong));
				grids.put(grids.size(), arrayList);
			}

		}
		return grids;
	}

	
	public static ArrayList<Integer> generateExtendedMap(int gridsize, Map<Integer, Boolean> r) {
		ArrayList<Integer> newrange = new ArrayList<Integer>();
		for (Integer i : r.keySet()) {
			if (r.get(i) == true) {
				int left = (i - 1) % gridsize != gridsize - 1 && (i - 1) % gridsize >= 0 ? i - 1 : i;
				int right = (i + 1) % gridsize != 0 ? i + 1 : i;
				int top = i - gridsize >= 0 ? i - gridsize : i;
				int bottom = i + gridsize < gridsize * gridsize ? i + gridsize : i;
				int top_left = i - gridsize > 0 && (i - gridsize - 1) % gridsize != gridsize - 1 ? i - gridsize - 1 : i;
				int top_right = i - gridsize >= 0 && (i - gridsize + 1) % gridsize != 0 ? i - gridsize + 1 : i;
				int bottom_left = i + gridsize < gridsize * gridsize && (i + gridsize - 1) % gridsize != gridsize - 1
						? i + gridsize - 1
								: i;
				int bottom_right = i + gridsize < (gridsize * gridsize) - 1 && (i + gridsize + 1) % gridsize != 0
						? i + gridsize + 1
								: i;
				if (left != i) {
					newrange.add(left);
				}
				if (right != i) {
					newrange.add(right);
				}
				if (top != i) {
					newrange.add(top);
				}
				if (bottom != i) {
					newrange.add(bottom);
				}
				if (top_left != i) {
					newrange.add(top_left);
				}
				if (top_right != i) {
					newrange.add(top_right);
				}
				if (bottom_left != i) {
					newrange.add(bottom_left);
				}
				if (bottom_right != i) {
					newrange.add(bottom_right);
				}
				newrange.add(i);
			}
		}
		return newrange;
	}


	public static Map<Integer, Boolean> SpotMe(Map<Integer, ArrayList<LatLng>> grids, double probability, LatLng current) {

		Map<Integer, Boolean> result = new HashMap<>();
		Random random = new Random();


		for (Integer r =0 ; r< grids.size();r++) {
			ArrayList<LatLng> locs = grids.get(r);
			if (random.nextDouble() < probability) {
				result.put(r, true);
				generated_locations.replace(r, generated_locations.get(r)+1);

			} else {
				if (locs.get(0).latitude >= current.latitude && locs.get(1).latitude <= current.latitude
						&& locs.get(0).longitude <= current.longitude && locs.get(1).longitude >= current.longitude) {
					result.put(r, true);
				} else {
					result.put(r, false);
				}
			}
		}
		return result;
	}




	static class location {
		Double lat;
		Double lng;

		public Double getLat() {
			return lat;
		}

		public void setLat(Double lat) {
			this.lat = lat;
		}

		public Double getLng() {
			return lng;
		}

		public void setLng(Double lng) {
			this.lng = lng;
		}

		public location(Double lat, Double lng) {
			super();
			this.lat = lat;
			this.lng = lng;
		}

		public location() {
			super();
		}

		@Override
		public String toString() {
			DecimalFormat ft = new DecimalFormat("####.########");
			// return "location [lat=" + ft.format(lat) + ", lng=" + ft.format(lng) + "]";
			return "[" + ft.format(lat) + ", " + ft.format(lng) + "]";
		}
	}

	static class map {
		String id;
		location loc;

		public map(String id, location loc) {
			super();
			this.id = id;
			this.loc = loc;
		}

		public map() {

		}

		@Override
		public String toString() {
			return "map [id=" + id + ", loc=" + loc + "]";
		}
	}
}
